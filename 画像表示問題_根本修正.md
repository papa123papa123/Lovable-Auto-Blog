# 画像表示問題の根本的な修正

## 問題の本質

画像が表示されない根本的な原因は、**プレビュー用の絶対URL**と**HTML用の相対パス**を区別していなかったことでした。

### 以前の問題

```typescript
// 以前の型定義（問題あり）
export type GeneratedArticle = {
  eyecatchImage?: { pc: string; mobile: string };  // これは絶対URL？相対パス？
  sectionImages?: Array<{ pc: string; mobile: string } | null>;
}
```

この設計では：
- プレビュー表示する時は**絶対URL**が必要（GitHub Pages URL）
- HTMLをデプロイする時は**相対パス**が必要（`images/eyecatch-800.webp`）
- **1つのフィールドで両方を表現できない** → バグの原因

### 発生していた問題

1. **プレビューで画像が表示されない**
   - HTMLに相対パスが埋め込まれているが、iframe内では読み込めない
   
2. **HTML再生成時にパスが混在**
   - ストレージから復元した記事のパスが不明確
   
3. **localStorageのクォータエラー時に画像が消える**
   - 古いフィールド名を参照していた

## 修正内容

### 1. GeneratedArticle型の修正

```typescript
export type GeneratedArticle = {
  keyword: string;
  productKeyword?: string;
  outline?: ArticleOutline;
  sections?: GeneratedSection[];
  
  // 🆕 プレビュー用の画像（絶対URL - GitHub Pages）
  eyecatchImagePreview?: { pc: string; mobile: string };
  sectionImagesPreview?: Array<{ pc: string; mobile: string } | null>;
  
  // 🆕 HTML用の画像（相対パス - デプロイ後）
  eyecatchImageHtml?: { pc: string; mobile: string };
  sectionImagesHtml?: Array<{ pc: string; mobile: string } | null>;
  
  htmlContent?: string;
  totalCharCount?: number;
  researchData?: KeywordResearchResult;
};
```

### 2. 画像生成時の処理（Dashboard.tsx）

```typescript
if (imageResult.success) {
  // プレビュー用に絶対URL（GitHub Pages URL）を保存
  eyecatchImagePreview = imageResult.eyecatchImageAbsolute;
  sectionImagesPreview = imageResult.sectionImagesAbsolute;
  
  // HTML用に相対パスを保存（デプロイ後用）
  eyecatchImageHtml = imageResult.eyecatchImage;
  sectionImagesHtml = imageResult.sectionImages;
}

// HTML生成時は相対パスを使用
const htmlContent = articleGeneratorApi.generateHtml(
  outline, 
  sections, 
  eyecatchImageHtml,  // ← 相対パス
  sectionImagesHtml,  // ← 相対パス
  icons, 
  productLinks
);

// 記事データには両方を保存
setCurrentArticle(prev => prev ? {
  ...prev,
  eyecatchImagePreview,  // ← 絶対URL（プレビュー用）
  sectionImagesPreview,  // ← 絶対URL（プレビュー用）
  eyecatchImageHtml,     // ← 相対パス（HTML用）
  sectionImagesHtml,     // ← 相対パス（HTML用）
  htmlContent,
} : null);
```

### 3. HTML再生成時の処理（Dashboard.tsx）

```typescript
// HTMLを再生成（HTML用の相対パスを使用）
const htmlContent = articleGeneratorApi.generateHtml(
  currentArticle.outline,
  currentArticle.sections,
  currentArticle.eyecatchImageHtml,  // ← 相対パス
  currentArticle.sectionImagesHtml,  // ← 相対パス
  icons,
  []
);
```

### 4. プレビュー表示時の処理（ArticlePreview.tsx）

#### 構成ビュー
```typescript
{article.eyecatchImagePreview ? (
  <picture>
    <source media="(max-width: 768px)" srcSet={article.eyecatchImagePreview.mobile} />
    <source media="(min-width: 769px)" srcSet={article.eyecatchImagePreview.pc} />
    <img src={article.eyecatchImagePreview.pc} alt="アイキャッチ画像" />
  </picture>
) : null}
```

#### HTMLプレビュー（iframe）
```typescript
const previewUrl = useMemo(() => {
  if (!article?.htmlContent) return null;
  
  let htmlContent = article.htmlContent;
  
  // 相対パスを絶対URLに置換
  if (article.eyecatchImagePreview) {
    htmlContent = htmlContent.replace(
      /src="images\/eyecatch-800\.webp"/g,
      `src="${article.eyecatchImagePreview.pc}"`
    );
    // ... 他の置換
  }
  
  return URL.createObjectURL(new Blob([htmlContent], { type: "text/html" }));
}, [article?.htmlContent, article?.eyecatchImagePreview, article?.sectionImagesPreview]);
```

### 5. ストレージ処理の修正（article-storage.ts）

```typescript
// クォータエラー時は両方の画像を削除
const lightArticles = articles.map(a => ({
  ...a,
  eyecatchImagePreview: undefined,
  sectionImagesPreview: undefined,
  eyecatchImageHtml: undefined,
  sectionImagesHtml: undefined,
}));
```

## 動作フロー

### 画像生成時
1. Gemini APIで画像生成（Base64）
2. 画像を最適化（WebP変換、リサイズ）
3. GitHubにアップロード
4. **絶対URL**と**相対パス**の両方を取得
5. GeneratedArticleに両方を保存

### プレビュー表示時
- **構成ビュー**: `eyecatchImagePreview`（絶対URL）を直接表示
- **HTMLプレビュー**: HTMLの相対パスを`eyecatchImagePreview`（絶対URL）に置換して表示

### HTML生成・デプロイ時
- `eyecatchImageHtml`（相対パス）を使ってHTMLを生成
- デプロイ後は画像ファイルと同じディレクトリにあるため、相対パスで読み込める

## これで解決した問題

✅ プレビューで画像が正しく表示される（絶対URL使用）
✅ デプロイ後のHTMLで画像が正しく表示される（相対パス使用）
✅ HTML再生成時も正しいパスを使用
✅ ストレージから復元した記事も正しく表示
✅ localStorageのクォータエラー時も適切に処理

## まとめ

**根本的な問題**: 1つのフィールドで「プレビュー用」と「デプロイ用」の2つの異なるパスを扱おうとしていた

**解決策**: 用途ごとに明確にフィールドを分離
- `eyecatchImagePreview` / `sectionImagesPreview`: プレビュー用（絶対URL）
- `eyecatchImageHtml` / `sectionImagesHtml`: HTML用（相対パス）

これにより、すべての場面で正しいパスが使用されるようになりました。
